/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "02.00.03"
}

/**
 * Monoprice Plug in Power Monitor
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2020-10-15 - (v02.00.03) Update for new ST app custom controls, do refresh after configure
 * 2020-02-06 - (v01.00.05) Update device health
 * 2019-01-14 - (v01.00.04) Update for restoring default values in preferences if invalid option is entered
 * 2018-08-05 - (v01.00.03) Added health check capability
 * 2018-08-02 - (v01.00.02) Added basic support for new ST app
 * 2018-02-14 - (v01.00.01) Show 1 decimal point for values
 * 2017-08-10 - (v01.00.00) Initial public release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
 */

preferences {
    input title: "", description: "Monoprice Plug in Power Monitor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "[Advanced Settings]", description: "Set how often you would like the plug to report the statistics. Leave it blank to use the default values (60 seconds and 50 watts).", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "meteringInterval", "number", title: "...report energy usage every (seconds)", required: false, displayDuringSetup: false, range: "60..255"
    input "meteringSensitivity", "number", title: "...if power usage changes by (watts)", required: false, displayDuringSetup: false, range: "5..3600"
}

metadata {
	definition (name: "Monoprice Plug in Power Monitor", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "oic.d.switch", mnmn: "SmartThingsCommunity", vid:"8be86b4c-dcf8-3333-abd8-b9bfc073a4d7") {
        capability "Actuator"
		capability "Sensor"
		capability "Energy Meter"
		capability "Power Meter"
        capability "Voltage Measurement"
        capability "Switch"
        capability "Relay Switch"
        capability "Outlet"
		capability "Refresh"
		capability "Polling"
        capability "Configuration"
		capability "Health Check"
        capability "rboyapps.currentMeasurement"
        capability "rboyapps.pfMeasurement"
        capability "rboyapps.energyKvahMeasurement"
        capability "rboyapps.energyReset"
        capability "rboyapps.versioning"
        
        ///attribute "codeVersion", "string"
        ///attribute "dhName", "string"
        ///attribute "current", "number"
        ///attribute "pf", "number"
        ///attribute "energykVAh", "number"

		///command "resetEnergy"

        // v1 fingerprints
        fingerprint deviceId:"0x1001", inClusters:"0x5E,0x72,0x86", manufacturer: "Monoprice", model: "15903" // Z-Wave Mini Plug
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"1001", cc:"5E,72,86", mfr: "0109", prod: "201A", model: "1AA4", deviceJoinName:"Monoprice Plug in Power Monitor 15903"
	}

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "lighting", width: 6, height: 4, canChangeIcon: true){
			tileAttribute ("device.switch", key: "PRIMARY_CONTROL") {
				attributeState "on", label: '${name}', action: "switch.off", icon: "st.switches.switch.on", backgroundColor: "#00A0DC", nextState: "off"
				attributeState "off", label: '${name}', action: "switch.on", icon: "st.switches.switch.off", backgroundColor: "#ffffff", nextState: "on"
			}
        }

		valueTile("power", "device.power", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} W'
		}
		
        valueTile("energy", "device.energy", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} kWh', action:"resetEnergy"
		}
		
        valueTile("energykVAh", "device.energykVAh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} kVAh', action:"resetEnergy"
		}
		
		valueTile("voltage", "device.voltage", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} V'
		}
		
		valueTile("amperage", "device.current", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} A'
		}

		valueTile("powerfactor", "device.pf", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue}'
		}

        standardTile("refresh", "device.switch", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}

        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'Configure', action:"configure"
		}

        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        main(["summary"])
        details(["summary","voltage","amperage","power","energy","energykVAh","powerfactor","blank2x","refresh","blank2x"])
    }
}

import groovy.transform.Field

@Field final int RESET_DELAY = 2

// Sent delayed event
def delayedEvent(data) {
    log.trace "Sending delayed event: $data"
    sendEvent(data)
}

def uninstalled() {
    log.trace "Uninstalled called"
}

def installed() {
	log.trace "Installed called settings: $settings"

    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
	
    try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "Installed() threw $e"
	}
}

def updated() {
	log.trace "Update called settings: $settings"

    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
	
    try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def ping() {
	log.trace "Ping called"
	// Just get device state, there's no need to flood more commands
	sendHubCommand(new physicalgraph.device.HubAction(command(zwave.basicV1.basicGet())))
}

def parse(String description) {
	//log.trace "$description"
    
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Monoprice Plug in Power Monitor"]) // Save DH Name for parent app

    def result = null
	if (description.startsWith("Err 106")) {
        log.warn("Z-Wave error '$description'")
		state.sec = 0
		result = createEvent(descriptionText: description, isStateChange: true)
	} else if (description != "updated") {
		def cmd = zwave.parse(description, [0x72:2, 0x73:1, 0x25:1, 0x70:1, 0x27:1, 0x20:1, 0x85:2, 0x32:3, 0x98:1]) // cannot use 0x71: 4 as ST only supports upto v3, cannot use 0x32: 4 since it only supports upto 3
		if (cmd) {
			result = zwaveEvent(cmd)
			log.debug("Parsed to $result")
		} else {
			log.warn("Couldn't zwave.parse '$description'")
		}
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    //log.trace "SecurityMessageEncapsulation $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x72:2, 0x73:1, 0x25:1, 0x70:1, 0x27:1, 0x20:1, 0x85:2, 0x32:3]) // cannot use 0x71: 4 as ST only supports upto v3, cannot use 0x32: 4 since it only supports upto 3
	if (encapsulatedCommand) {
        state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

// Process switch on/off reports
private switchReport(cmd, pressType = "physical") { // default is physical unless we switched it
    def result = []
    
    result << createEvent(name: "switch", value: cmd.value ? "on" : "off", type: pressType) // TODO: How do we differentiate between physical and digital?
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
    log.trace "BasicReport: $cmd"
    switchReport(cmd, "digital")
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
    log.trace "SwitchBinaryReport: $cmd"
    switchReport(cmd)
}

def zwaveEvent(physicalgraph.zwave.commands.switchallv1.SwitchAllReport cmd) {
    log.trace "SwitchAll: $cmd"
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.powerlevelv1.PowerlevelReport cmd) {
    log.trace "PowerLevel: $cmd"
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
    log.trace "AssociationReport: $cmd"

    if (cmd.nodeId.any { it == zwaveHubNodeId }) {
        log.trace "$device.displayName is associated to $zwaveHubNodeId via group $cmd.groupingIdentifier"
    }
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd) {
    log.trace "Notification: $cmd"
    
    def result = []
    switch (cmd.notificationType) {
        default:
            log.warn "Unknown Notification: $cmd"
            break
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.meterv3.MeterReport cmd) {
    //log.trace "MeterReport: $cmd"
    
    def result = []
    
	if (cmd.scale == 0) {
		result << createEvent(name: "energy", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kWh")
	} else if (cmd.scale == 1) {
		result << createEvent(name: "energykVAh", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kVAh")
	} else if (cmd.scale == 2) {
		result << createEvent(name: "power", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "W")
	} else if (cmd.scale == 4) {
		result << createEvent(name: "voltage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "V")
	} else if (cmd.scale == 5) {
		result << createEvent(name: "current", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "A")
	} else if (cmd.scale == 6) {
		result << createEvent(name: "pf", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0))
	} else {
        log.warn "Unknown Meter Report: $cmd"
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    switch (cmd.parameterNumber) {
        case paramMap.MeteringFrequency.Param:
        	log.info "Metering frequency ${getParamMap(cmd.configurationValue).MeteringFrequency.Value} seconds"
            break
            
        case paramMap.MeteringThreshold.Param:
        	log.info "Metering reporting threshold ${getParamMap(cmd.configurationValue).MeteringThreshold.Value} watts"
            break

        default:
        	log.warn "Unknown configuration report: $cmd"
            break
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)
	updateDataValue("manufacturer", cmd.manufacturerName)

    result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)

	result
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "$device.displayName: $cmd"
	[:]
}

def on() {
    log.trace "Turning switch on"
    
    def cmds = []
    cmds << command(zwave.basicV1.basicSet(value: 0xFF))
    cmds << refresh(false)
    delayBetween(cmds, 500)
}

def off() {
    log.trace "Turning switch off"
    
    def cmds = []
    cmds << command(zwave.basicV1.basicSet(value: 0x00))
    cmds << refresh(false)
    delayBetween(cmds, 500)
}

def setReset(delay = null) {
    log.trace "Resetting energy with delay $delay"
    resetEnergy()
}

def resetEnergy() {
    log.trace "Resetting energy"
    sendEvent(name: "resetEnergy", value: "resetting", isStateChange: true, descriptionText: "Resetting energy meter")
    runIn(RESET_DELAY, delayedEvent, [data: [name: "resetEnergy", value: "ready", isStateChange: true]])

    commands([
		zwave.meterV3.meterReset(),
		zwave.meterV3.meterGet(scale: 0),
		zwave.meterV3.meterGet(scale: 1),
	])
}

def refresh(queryConfig = true) {
    log.trace "Refresh called, refresh config params: ${queryConfig}"
    
    def cmds = []

    // We need the MSR
    if (!state.MSR) {
        log.debug "Getting MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet() // Get MSR
    }
    
    //cmds << zwave.switchAllV1.switchAllGet()
    //cmds << zwave.powerlevelV1.powerlevelGet()
    //cmds << zwave.switchBinaryV1.switchBinaryGet() // We get physical changes using BinarySwitch and Digital with Basic
    cmds << zwave.basicV1.basicGet() // This is only for digital
    cmds << zwave.meterV3.meterGet(scale: 0) // kWh
    cmds << zwave.meterV3.meterGet(scale: 1) // kVAh
    cmds << zwave.meterV3.meterGet(scale: 2) // W
    cmds << zwave.meterV3.meterGet(scale: 4) // V
    cmds << zwave.meterV3.meterGet(scale: 5) // A
    cmds << zwave.meterV3.meterGet(scale: 6) // PF

    if (queryConfig) {
        paramMap.each { key, value ->
            cmds << zwave.configurationV1.configurationGet(parameterNumber: value.Param)
        }
    }
    
    if (!queryConfig) { // Coming from a manual request, don't send command
        commands(cmds)
    } else {
        sendHubCommand(response(commands(cmds)).toHubAction()) // Send actions to hub since this is called offline
    }
}

def poll() {
    log.trace "Poll called"
	refresh()
}

def configure() {
    log.trace "Configure called:\nDescription: ${getRawDescriptionMap()}\nZWInfo: ${zwaveInfo}"
    
    sendEvent(name: "resetEnergy", value: "ready", displayed: false)
    if (device.currentValue("current") == null) {
        sendEvent(name: "current", value: (float) (0.0), unit: "A")
    }
    if (device.currentValue("pf") == null) {
        sendEvent(name: "pf", value: (float) (0.0))
    }
    
    def cmds = []
    
    // Bug with ST firmware 18.x, since this device doesn't advertise secure capabilities in the CC list (0x98), ST doesn't so a secure association which is required for 15903 device, so we have to complete the assocaition manually and set the channel to secure
    if (zwaveInfo.zw && !zwaveInfo.zw.contains("s")) {
        log.debug "Non-secure inclusion"
    } else {
        log.debug "Forcing secure channel inclusion and communication"
        state.sec = 1
        cmds << zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId) // Bug with the 15903 device not publishing 0x98 in CC
    }

    log.debug "Getting MSR"
    cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet() // Get MSR

    log.debug "Settings metering report interval to ${meteringInterval ?: paramMap.MeteringFrequency.Default} seconds"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringFrequency.Param, configurationValue: getParamMap(meteringInterval ?: paramMap.MeteringFrequency.Default).MeteringFrequency.ParamValue, size: paramMap.MeteringFrequency.Size)

    log.debug "Setting metering report change sensitivity to ${meteringSensitivity ?: paramMap.MeteringThreshold.Default} watts"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringThreshold.Param, configurationValue: getParamMap(meteringSensitivity ?: paramMap.MeteringThreshold.Default).MeteringThreshold.ParamValue, size: paramMap.MeteringThreshold.Size) // Set highest sensitivity
    
    // Get all parameters
    paramMap.each { key, value ->
        cmds << zwave.configurationV1.configurationGet(parameterNumber: value.Param)
    }
    
    runIn(60, refresh) // Give it 60 seconds to finish up and then get a refresh
    
    commands(cmds)
}

private command(physicalgraph.zwave.Command cmd) {
    //log.trace cmd
    //log.trace "Secure: $state.sec"
	if (state.sec) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private commands(commands, delay=300) { // Some of these params need more time to get on this switch or they are dropped
	delayBetween(commands.collect{ command(it) }, delay)
}

private getParamMap(value = null) {
	[
        "MeteringFrequency": 	[ Param: 1, Size: 1, Default: 60, Min: 60, Max: 255, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringThreshold": 	[ Param: 2, Size: 2, Default: 50, Min: 5, Max: 3600, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

// Get the Raw Description of the device and turns into a map
private getRawDescriptionMap() {
    def arr = device?.rawDescription?.split(" |:")
    def map = [:]
    for (int i=0; i<arr.length-1; ) {
        map.put(arr[i++], arr[i++])
    }
    return map
}


// THIS IS THE END OF THE FILE


